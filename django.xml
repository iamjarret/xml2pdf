<?xml version="1.0"?>
<presentation>
	<title name = "Django Overview" date="February 11th, 2013"/>
	<slide title = "Why does this presentation exist?">
		<p>The Djangobook (djangobook.com) covers in-depth applications and goes through an example of starting a
		framework to handle publishing/book data</p>
		<p>The goal of this presentation is to summplement that very detailed project
		by providing a list of the tools and resources available in each section as a reference</p>
		<p>It will also try to connect some of the dots between chapters when there's a logical way of doing so </p>
		<p tab="1">As such some of the titles may have different names than the Django book</p>
		<p>Reminders:</p>
		<p tab="1">"Beautiful is better than ugly"</p>
		<p tab="1">"Special cases aren't special enough to break the rules"</p>
	</slide>
	<slide title= "Agenda">
		<p>Directory structure</p>
		<p>Views and URLconfs</p>
		<p>Templates</p>
		<p>Models</p>
		<p>Django.contrib: the admin site</p>
	</slide>
	<slide title="Directory structure">
		<p>Starting a project:  django-admin.py startproject mysite</p>
		<p>This code creates a new directory named 'mysite' in the current directory</p>
		<p>Within 'mysite' is a file named 'manage.py' and a subfolder also named 'mysite'</p>
		<p tab="1">'manage.py' is a small file that directs the python shell to the location of the 'settings.py' file</p>
		<p tab="1">Note: a template directory could be added here to contain HTML templates</p>
		<p>Within the subdirectory 'mysite.py' are 5 files: 'settings.py', 'views.py', 'urls.py', 'init.py', and 'wsgi.py'(?)</p> 
		<p tab="1">Apps will also live in this subdirectory (Django interacts with SQL through models and models are part of an app)</p>
		<p tab="1">python manage.py startapp myapp</p>
		<p tab="2">The app directory contains 'models.py', 'views.py', and 'tests.py'</p>
	</slide>
	<section name="Views and URLconfs"/>
	<slide title="HttpRequest -> URLconf -> function within views.py">
		<p>The URLconf is a list that connects website addresses with their appropriate functions within the views.py file </p>
		<p>URL conf is a URL pattern [django.conf.urls.defaults.patterns] which is a list of tuples that contains a regular expression
		and the name of the function in views.py (function name only - not as a text string and without paranthesis)</p>
		<p>At it's most abstract level, a function in views.py takes a HttpRequest and returns a HttpResponse [django.http.HttpResponse]</p>
		<p tab="1">For capturing text from the url, captured text needs to be defined in the regular expression</p>
		<p tab="1">i.e. (r'^time/plus/\d+/$', hours_ahead) uses \d+ to match any number of digits and pass to function hours_ahead 
		in views.py.  '\d{1,2}' would take 1 or 2 digits in that space</p>
		<p tab="2">These digits are CAPTURED AS UNICODE STRINGS, not integers</p>
		<p tab="1">This function in view.py would be defined as: 'def hours_ahead(request, offset):' - with the first 
		parameter as the HttpRequest </p>
	</slide>
	<slide title="Functions in views.py">
		<p>The HttpResponse [django.http.HttpResponse] takes as input an html string</p>
		<p tab="1">This isn't good since it doesn't meet Django's goal of seperating concerns (i.e. why should html be hard
		coded deep in the backend functionality of the site?)</p>
		<p>The answer is that is shouldn't be - this is where HTML templates come in</p>
		<p>To make calling a template, providing a context and rendering to HTML easier, Django provides a shortcut in render_to_response
		[django.shortcuts.render_to_response]</p>
		<p tab="1">Example: return render_to_response('current_datetime.html', {'current_date': now}) </p>
		<p>Error handling within views.py</p>
		<p tab="1">The 404 page exception [django.http.Http404] should be raised (code: raise Http404() )if the string (unicode object) can't be converted into 
		a value </p>
		<p tab="1">At any point in your code, you can trigger the error page and stop the code by adding the statement 'assert False'</p>
	</slide>
	<section name="Templates: using Django's stand-alone template language"/>
	<slide title="The Django template library is nothing special nor specific to building a web framework">
		<p>In 'settings.py' add the drive where your templates live to 'TEMPLATE_DIRS'</p>
		<p tab="1">Commands that can help with this are: [os.path.join], [os.path.dirname], and the "magic" __file__ variable </p>
		<p>After this step, nothing else about the pre-built template language is specific to building a website</p>
		<p>The two relevant classes are a template [django.template.Template] and context [django.template.Context]</p>
		<p tab="1">a context is a dictionary object with added functionality which is created from a dictionary object</p>
		<p tab="1">a template processes text written in Django's template library language and most importantly can be rendered
		('t.render(c)'-where c is a context) into an HTML string </p>
	</slide>
	<slide title="Basic template syntax">
		<p>A variable is added with '{{item.car}}' code.  Where item is a dictionary object (and car is a key in it), a custom class
		(with car being an attribute), or car can be a function</p>
		<p tab ="1">Django uses the following order: dictionary lookup (e.g., item["car"]), attribute lookup (e.g., item.car), method call 
		(e.g., item.car()) and finally list-index lookup (e.g., item[2])</p>
		<p tab="1">The method call handling is handy and allows you to use 'upper' or other string formatting functions</p>
		<p>Filters are a way to change the format automatically (i.e. '{{ ship.arrival_date | date: "F j, Y" }}') some common filters are: 
		first, last, truncatewords:"30", addslashes, date, length (full list in Appendix F of the Django book)</p>
		<p>For loops '{% for item in item_list %}' requires an end syntax of '{% endfor %}'</p>
		<p>If loops are written as '{% if ordered_warranty %}', '{% else %}', and '{% endif %}'</p>
		<p>Ifequal loops are written as '{% ifequal user currentuser %}, {% else %}, {% endifequal %} where currentuser could be a 
		hard-coded string, decimal, integer, or template varable</p>
		<p>Comment syntax: '{# This is a comment #}' or '{% comment %}' and '{% endcomment %}' for multi-line comments</p>
	</slide>
	<slide title ="Boolean logic">
		<p>The "if" tag accepts 'and', 'or', or 'not' but it doesn't accept parantheses</p>
		<p tag="1">This means that ambiguous statements (i.e. combing 'and' and 'or') aren't accepted, but these can be
		evaluated outside the html template</p>
		<p tag="1">There is no 'elif' but nested 'ifs' under the 'else' clause accomplish the same thing</p> 
		<p>Remember, the following evaluate to False: empty list ([]), empty tuple (()), 
		empty dictionary ({}), empty string (''), zero (0), the special object None, and custom objects that 
		define their own Boolean context behavior</p>
		<p>Because the operation of testing whether something is empty and if not looping over it is so common, there is a shortcut
		for doing this: the '{% empty %}' tag placed after '{% for athlete in athlete_list %}' will be evaluated only if athlete_list
		is empty</p>
		<p>The 'for' tag has higher level processing with the 'forloop' variables</p>
		<p tab="1">forloop.counter, forloop.counter0, forloop.revcounter, forloop.revcounter0, forloop.first (boolean set to True if this
		is the first time through the loop), forloop.last, forloop.parentloop (a reference to the parent's forloop object in nested for
		loops - 'forloop.parentloop.counter')</p>
	</slide>
	<slide title="Error handling">
		<p>In the method call, an unknown variable (AssertionError) will raise an error unless 'silent_variable_failure=True'</p>
		<p>Some functions shouldn't be executed in templates (i.e. delete).  Because of this, functions can have an 'alter_data'
		method.  If 'alters_data=True' the template won't execute the method even when called</p>
		<p>By default variables that don't exist fail silently and are rendered as an empty string</p>
	</slide>
	<slide title="The include tag and template inheritance">
		<p>The '{% include 'nav.html' %}' tag allows for the inclusion of the contents of another template</p>
		<p>When not in debug mode the include tag fails silently and is evaluated as an empty string.  If in debug mode a misnamed
		template raises a TemplateDoesNotExist exception</p>
		<p>Template inheritance inverts the idea of the include tag by defining common blocks in the parent template that children
		can override</p>
		<p tab="1">{% block title %}{% endblock %}, {% block content %}{% endblock %}, {% block footer %}{% endblock %}</p>
		<p tab="1">Anything that appears between block templates is added if the child doesn't define anything for that block</p>
		<p>Typically sites are organized using three levels of organization: base.html, base_section.html, and individual pages</p>
		<p>Children can inherit generic output using the {{ block.super }} tag which is useful to add to code</p>
		<p>The string in {% extends "XXX.html" %} can also be a variable, allowing for more dynamic development</p>
	</slide>
	<section name="Models"/>
	<slide title="Configuring settings.py and testing">
		<p>Unless you are using SQLite, the database must be created beforehand (i.e. CREATE DATABASE)</p>
		<p>'DATABASE_ENGINE' must be set to the SQL backend being used (an appropriate adapter must also be installed)</p>
		<p>'DATABASE_NAME' must be set to the name of the database unless you are using SQLite in which case this must be the
		full pathname of the db</p>
		<p>'DATABASE_HOST' should be left blank if using a local db (if using SQLite use full path beginning with a backslash).  
		'DATABASE_PORT' if blank defers to the underlying adapter</p>
		<p>To test that the database settings are correct, enter the python shell (python manage.py shell) and run
		connection.cursor() [django.db.connection]</p>
		<p tab="1">"Error loading ____ module" means adapter is not installed</p>
		<p tab="1">"Database ____ doesn't exist" means db_name is incorrect</p>
		<p tab="1">"Role ____ doesn't exist" means db_user is incorrect</p>
		<p tab="1">"Could not connect to server" means db_host or db_port is incorrect</p>
	</slide>
	<slide title="The Django app: a bundle of models and views that is needed to support the database layer">
		<p>A project is an instance of django apps plus a configuration file, while apps are meant to be portable and reusable</p>
		<p>Models define data models that are translated directly into SQL</p>
		<p tab="1">One drawback of this redundancy is that an underlying database may be out of sync with the django model</p>
		<p>A model is a subclass of models.Model [django.db.models] and fields/relationships are defined using functions
		within the models dir</p>
		<p tab="1">Common field/relationship definitions: name = models.CharField(max_length=30), models.URLField(), 
		models.EmailField(), models.ManyToManyField(Author), models.ForeignKey(Publisher), models.DateField()</p>
		<p>To install the app add the directory to 'INSTALLED_APPS' in 'settings.py'</p>
		<p>To validate models: 'python manage.py validate'</p>
		<p>To see the SQL code that your model generates use 'python manage.py sqlall books' ('python manage.py syncdb' actually 
		create the tables)</p>
	</slide>
	<slide title="Saving, updating and selecting data">
		<p>To add model string representations add 'def __unicode__(self): return self.name' to the model class</p>
		<p>Model instances can be created by using the standard class name but it won't be saved to the db until the 
		save() method is called</p>
		<p>If model attributes are updated, running save() method only changes the updated attribute in the db</p>
		<p tab="1">This is a confusing point.  If a search is used to find the variable to update, django will resave every
		attribute to the db - even those that aren't updated</p>
		<p>'Publisher.objects.all()' where "Publisher" is the model and "objects" is the manager which handles table-level operations)</p>
		<p>'Publisher.objects.filter(name='Apress')' is translated into an appropriate 'WHERE'SQL command (multiple filters accepted)</p>
		<p tab="1">By default this uses the SQL "=" operator.  Other operators can be used with the DOUBLE underscore - 
		'filter(name__contains="press")'</p>
	</slide>	
	<slide title="Saving, updating and selecting data (continued)">
		<p>To retrieve a single object use 'Publisher.objects.get(name="Apress")'.  Any query that returns mutliple objects will cause
		a MultipleObjectsReturned error</p>
		<p>Data can be ordered using 'objects.order_by("name")' or a default ordering can be specified
		by adding 'class Meta: ordering = ['name']' to the model class</p>
		<p tab="1">A dash in the ordering name "-name" vs. "name" returns the reverse alphabetical order</p>
		<p>When searching the database and changing attribute names use the 'update' method 
		'objects.filter(id=52).update(name='NEW NAME')' or else the whole entry will be updated</p>
	</slide>
	<section name="Django.contrib: The built-in admin site"/>
	<slide title="Activating the admin site">
		<p>Add 'django.contrib.admin' to the 'INSTALLED_APPS' setting</p>
		<p>The admin site is dependent on 'django.contrib.auth', 'django.contrib.contenttypes', and 'django.contrib.sessions' so these muse be
		added to 'INSTALLED_APPS' as well</p>
		<p>Ensure that the 'MIDDLEWARE_CLASSES' includes 'django.middleware.common.CommonMiddleware', 
		'django.contrib.sessions.middleware.SessionMiddleware, and 'django.contrib.auth.middleware.AuthenticationMiddleware'</p>
		<p>Then run 'python manage.py syncdb' to create the necessary admin databases</p>
		<p>You'll be promped to create a superuser, these users can be added later using 'python manage.py createsuperuser'</p>
		<p>Add the admin site to URLconf: '(r'^admin/', include(admin.site.urls))'</p>
	</slide>
	<slide title="Adding models to the admin site">
		<p>Within your app folder create a file named 'admin.py', import models + admin [django.contrib], then register each model 
		'admin.site.register(MODEL)'</p>
		<p>The admin site is based off meta data from the model specification, this means to allow blank or null values blank=True and null=True
		must be added to the model</p>
		<p>Blank and null are not the same thing - blank is an empty string, null means the value isn't defined</p>
		<p>We need both because for example a date file can't be an empty string because it would be of the wrong form, it 
		it is blank it must be null</p>
		<p>Database must be updated if adding "Null=True" to model since it changes the autogenerated SQL</p>
		<p>Once database is configured, you can use 'manage.py dbshell' to enter SQL shell</p>
		<p>To customize field labels use verbose name in model specification, or more compactly if a string is the first
		variable in the model specification this will be automatically interpreted as the verbose_name tag</p>
	</slide>
	<slide title="ModelAdmin classes">
		<p>Admin classes are instances of admin.ModelAdmin [django.contrib.admin] and live in 'admin.py'</p>
		<p>The admin class can be passed to the register command as the second argument</p>
		<p>Can now use higher-level built in features: list_display = ('first_name', 'last_name', 'email'), search_fields = ('first_name', 'last_name')
		, list_filter = ('publication_date',), date_hierarchy = 'publication_date', ordering = ('-publication_date',)</p>
		<p>The 'fields' variable let's you stipulate a tuple of editable fields - everything else will be filled in as Null</p>
		<p>For ManyToManyFields, the 'filter_horizontal' changes the display from a box to a nicely formatted selection box</p>
		<p>For ForeignKey use raw_id_fields = ('publisher',) to use a search box instead of a list</p>
	</slide>
</presentation>
